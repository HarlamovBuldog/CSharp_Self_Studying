//Общая модель в голове
>/
View First берем, потому что не до конца понятен функционал
1) View:
 - Dock Panel + Grid + Stock Panel (можно взять вьюшку с примера с Хабра).
 - Скорее всего 2 xaml будет. Одна юзерка будет брать шаблоны с Мэйна.
 - В юзерке будут динамически появляться кнопки, по нажатию на которые идет переброс
в новое окно с созданием группы, а в группе динамически будут создаваться товары конкретной группы.
Для товаров, аналогично группам, при нажатии будет появляться окно с добавлением фото + инфа.
Тут возникает вопрос как сделать этот переброс. Всё-таки нужен трансфер и может не юзерка, а страницы.
Вообщем остаются вопросы. Каким-то образом ещё нужно организовать генерацию страниц, потому что как только 
на одной странице заканчивается место, должна создаватсья вторая страница и переходка. Причем схема схожая 
для группы и для товаров. Тоесть будут похожие темплэйты.
2) Model:
 - В модели однозначно должна хранится коллекция групп и товаров внутри групп. Причём коллекция должна заноситься
 в БД, чтобы при повторном открытии она подгружалась.
 - Нужен также функционал по созданию XML-файла, фаблон которого ещё надо взять и понять как именно он генерируется.
 - Я так понимаю, что нужны ещё функции редактирования всех элементов однозначно (групп и элементов внутри них).
3) VM:
 - Ну тут бы ещё разобраться все-таки до конца, что в VM, а что в Model.
 - По факту здесь привязки, работа с коллекциями, все raise event.
/<

/*
 А так вообщем, продебажить последний примерс Хабра фулл, понять как это всё работает.
 Очень дотошно понять. Каждую функцию, каждую строчку. Пооставлять комменты.
 Особенно райз ивентов, сама реализация паттерна и делегаты.

 Можно ещё профессор-вэб чекнуть и английский сайт на наличие инфы по динамическим страницам.
 Ещё бы по полочкам разобрать Prism в идеале. Потому что используется в этих примерах.
*/

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
По хорошему, мэйби на выходных надо поднимать базу c#+wpf
Можно конечно и дальше пытаться делать все на ходу, но
чем больше идешь дальше, тем больше вопросов. Мэйби это норм конечно.
Но рано или поздно я могу так повиснуть. Просто меня напрягает тот факт, что
я толком не понимаю, что происходит в проге. А это хреново, потому что ты не можешь 
контролировать код и то, что происходит впринципе.
Ещё возникла проблема с подключением к базе данных. Проблема в том, что локально подключаться к БД не самый
лучший вариант, в идеале было бы кодом это делать, тем более, что у меня будет подключение к нескольким БД.
Важно понять как Notify пробрасываются, а то чет я не бум-бум
Короче нужны гайдики, потому что всё контролить нужно, в том числе разбираться во всех файлах настройки 
и подгружать .dll, ибо это очень важно для будущего развертывания. 
Статейки Джон Смита и его проект-пример шикарен, прям чувствуется.
Осталось только фулл в нём разобраться и попробовать добавлять по-тихоньку свою логику. В чём впринципе 
и заключается сложность. Читать и разбираться, разбираться и читать, - всё, что остается.
Как вариант конечно найти видео с пошаговым руководством и созданием приложения. Но опять же скорее всего там будет 
другая логика и другой код. Есть видосик с MSDN с использованием Prism разве что.
Короче всё свелось к тому, что мне надо хотя бы присоединиться к БД и построить сеть из кнопок, каждая из которых
будет иметь контент в себе(тоесть название группы) и будет запускать триггер, теость переходить к элементам группы, где
так же будут выстроены кнопки элементов группы.
(Пора уже записывать дату этих записей сумасшедшего)

>/ 12/09/18
Короче с нуля поднять сложно, да и фишка в том, что у каждого "Тутора" свои методы связи элементов паттерна, в особенности
это касается навигации. Остановился на том, что надо править проект Josh Smith-та (MvvMDemoApp) либо wpf_Entity_Framework/, но там
мне покдлючение к Бд не нравится. По тиху появляется желание просто пересесть на Qt. По сути поактуальнее будет, хотя его тоже
с нуля поднимать надо, так что толку. Думаю легче явно не станет.
/<

>/ 13/09/18
Вообщем логику вроде как внедрить удалось. Ну как удалось, пока что у меня только создается новый TAB при нажатии кнопок слева, 
в котором у меня вывелись кнопки. Всё пока что супер допотопно в плане логики моей основной программы, но хоть какие-то шаги
навстречу. 
Надо теперь продумать как аккуратно без лажи внедрить чилдренят в прикуску к группам (кнопкам). Тут в любом случае нужен
новый класс, скорее всего даже фулл набор. Хоть они и связаны.
Ещё нужно как-то всё-таки тригерить IsSelected для кнопки. Пока что я нашел вариант на stackoverflow с превращением RadioButton 
во FlatButton (ссылка на источник в Телеграмме).
По моим раздумьям команды я каким-то образом должен задавать всё-таки в соответствующей ViewModel.
СМ. файл CustomerViewModel.cs => RelayCommand _saveCommand. В начале будет RelayCommand, который будет байндиться к кнопке.
Все равно в голове каша по поводу пробросов (или поднятий, фиг пойми) ивентов. Из-за этой дыры в понимании сложно двигаться
дальше. Надо ещё почитать про это либо опять пример разобрать, а лучше продебажить текущий.
Кстати касательно выбора и контроля IsSelected, в wpf_Entity_Framework набор кнопок и активация по выбору, тоесть другими словами 
трекинг статуса IsSelected. Вообщем есть куда смотреть, на заметку.
/<

>/ 14/09/18
Вообщем загвоздка главная в том, что в MainViewModel происходит переключение между списками workspace-ов (те же ViewModel). И грубо 
говоря всё переключение между View-ками идет через одно главное окно, в котором впринципе и расположены кнопки. Мне в любом случае нужна
система уходящая вглубь, ибо каждая моя View привязана к ViewModel. Тоесть все объекты будут привязаны к своей ViewModel. Таким образом, 
code-behind, грубо говоря для каждой из View нужно в любом случае прописывать в своей ViewModel. 
Ещё вроде как гениальная идея в голову пришла, ведь Close по сути то же ReturnBack. Тоесть по сути оно просто удаляет Workspace и возвращается
по иерархии выше (если я правильно понял конечно). В любом случае need to try it.
Наследование с использованием шаблонирования, начинаю допирать, зачем оно мне может пригодиться (ссылка на stackoverflow в telegram).
В таком случае даже можно сделать два базовых класса, от которых можно наследоваться. Один для UserControl добавления групп, 
второй для UserControl добавления элементов внутри групп.
В общем в конце концов очередной ступор. Проблема в биндинге вьюшки. Когда я ссылаюсь на Список с типом ГрупВьюМодел, то байдинг на команду
пытается найти эту команду в том же классе, а расписана моя команда в классе ОллГрупсВьюМодел. Короче скорее всего где-то просто логическая ошибка.
Либо вытекла наконец-то ошибка в архитектуре. Не понятно вообщем.
/<

>/ 17/09/18
Сделать иерархию с большего вроде как получилось. Допетрил в xaml файлах, что впринципе нам достаточно привязываться к коллекции кнопок, у каждой из которых
будет Дисплей Нэйм, который соответствует каждому следующему элементу в списке групп. А какие именно элементы групп генерить будет задавать функция через тот же параметр 
имени. Единственное, чем плох этот варик, так это тем, что при изменении и удалении любых элементов, надо поднимать ивенты на удаление и изменение этих кнопок.
Раньше модели Детишек в консоле не создавались. Теперь пришел к тому, что они хоят бы создаются. Однако переход всё равно не идёт. Причина была в том, что после того, как мы переходим
к Элл Чайлдз Вью Модел, мы выходим из скоупа Мэйна, в котором у нас идёт вся привязка Вьюшек к ВьюМоделям. Возможно эта же проблема и в навигации.
Вообщем скорее всего переключение между страницами в такой реализации может осуществляться только из MainViewModel. А команды для кнопок находятся с помощью 
указания Ancestor в свойствах кнопки для Command в .xaml файле. В итоге нужно пытаться достучаться до всего в мэйне. Ещё вычитал, что упрощают общение между UserControl фреймворки 
Prism или MVVM.Light. Вроде как именно они позволяют поднять ивенты главного окна (модели) из любого места. Короче WorthReading или WorthLearning.
Пока что пытаемся все всунуть в MainVM. Если не выйдет, надо будет разбирать Prism или MVVM.Light.
Даааа!! Хорошо. наконец-то вышло то, что я хотел впринципе. Сделал проброс фулл из мэйна и всё вышло.
Правда я все-таки воспользовался списком кнопок типа CommandViewModel, из-за которого, как я уже и говорил, придется райзить ивенты на изменение списка, в случае удаления группы либо 
редактирования названия группы. Но уже хоть что-то. Теперь надо заняться переделыванием вьюшек и Тэмплэйтов и дальше по-тихоньку всю логику прорабатывать.
/<

>/ 18/09/18
Вроде как навигацию сделал, а оказалось, что работы помимо навигации ещё много. Надо как-то начать с малого и постепенно перейти к более сложному. А мб наоборот.
Распишем задачки, так будет проще:
1)Полностью переработать дизайн Вьюшки (мне кажется это можно скорее на конец оставить, к черту этот дизайн).
Впринципе пока что кнопки либо сбоку оставить, либо все-таки боковую панель снести и сделать очень близко к примеру на скрине кассовой программы в Slack.
Тоесть оставить заголовок, пока что менюшка пусть будет, добавить подзаголовок (уже databinding есть на заголовке Workspace), кнопки можно разместить между заголовком и воркспэйсом.
2)Сделать коннект и выборку данных из БД, а не из xml-файла. Сюда конечно же идёт вся валидация и т.д., но это потом.
Так, по поводу коннекта. Сделать-то его вроде как изи. Для SQLlite своя библиотека подключается, для PostGres своя (всё гуглится).
Есть конечно варик, эти две базы данных наследовать от одного общего класса, чтобы уменьшить код. Ссылка на идею в Телеге.
Есть хорошая статья, где челик пытается показать, что можно удачно использовать .Net, и на основе того, что он предлагает, создавать динамичный SQL, использовать много баз данных,
в том числе любого типа. Там вроде как в комментах люди пишут, что есть свои особенности, но вроде мужик шарит в том, что впрягает. Вопрос как бы в другом, нужно ли мне реально парится 
за этот один интерфейс для всех Баз данных, когда их у меня всего по факту 2 штуки. Я думаю в этом реально нету смысла и надо брать и скачивать сторонние библиотеки.
Хотя это займёт много кода. Вообщем надо ещё вчитаться, если я проникнусь этой идеей и пойму как это сделать, то общий класс сделать можно. Только понять надо как от него наследоваться.
По идеи все, что касается коннекта, будет в папке DataAccess и заканчиваться на _Repository.
Нашел примеры как с using, так и с try/catch/finally, а иногда в комбинации. Что из них выбирать - не понятно.
3)В главном окне запрограммировать кнопки Add, Edit, Delete, которые будут работать со всеми элементами.
Здесь тоже сложность возникает, как котролить текущее окно. В одном из примеров (на основе статьи Josh Smith-а) парень заводил свойство CurrentViewModel и работал с ним.
Думаю это может быть одним из решений. Только нужно понять разницу в реализации связки команды+ивенты+делегаты этих двух товарищей.
4)Нужно создать всплывающие UserControl-ы при нажатии Add и Edit, для них ViewModel соответственно.
Add будет активна всегда. Edit и Delete будут смотреть на IsSelected кнопки (но это тоже, такая доп фича).
Так с функционалом этих кнопок все немного сложнее, там же выборка текста из ComboBox идёт, который в свою очередь берет данные из БД.
В любом случае надо потренироваться и с валидацией и с другими штуками, поэтому надо сделать. Хотя бы для групп. Потому что для детишек всё будет идентично.
К тому же в группах меньше полей.
5)Избавиться в конце концов от Customer-ов из примера лучше всего под конец (ибо я по темплейту все клепаю).
6)Xaml файлики мэйби тоже придется переделать. Не только в плане внешнего вида, а в плане правильного байдинга
и подбора правильных контентов (дополнение к п.1).
7)Вообще прям в самом конце конечно, можно все-таки попытаться ещё кнопку добавления добавить такую большую с плюсом внутри.
8)Вообще есть ещё конечно вопрос по навигации. Типа у нас 3 статических Вьюшки и коллекция по сути нам не нужна. Но потом, я подумал, что все равно динамически появляются и исчезают
всякие добавления элементов и Edit. Поэтому все-таки скорее всего оставляем такую схему.
Самые привлекающие пункты пока что 3 и 4. Думаю с них и стоит начать.
Все-таки с навигацией я по ходу рано порадовался. Ибо я тут понял, что у меня все группы ссылаются на один и тот же воркспейс с четырьмя чайладми. Я конечно это и подразумевал.
Только вот, когда решил всерьез задуматься, а как организовать разделение, стало не так весело.
Вообщем с организацией коннекта к БД не могу решиться. Тут либо реально серфить инет и искать решения либо опять брать то, что есть и работать с этим.
Здесь проблема в том, что можно повиснуть на этом. Поэтому надо делать фулл вьюху не столько по функционалу, сколько по внешнему виду, которая пока что будет редактить хотя бы xaml файлики.
Потому что с базами данных все равно не все прозрачно. Во всяком случае с тестовой БД, которая будет участвовать при создании и редактирования самих продуктов (Childs в переводе на прогу) точно
непрозрачно. Не совсем ясно, как и в какой контейнер впихнуть этот поиск по PostgreS БД.
Поэтому редактим вьюхи, в идеале кнопку "Назад" ещё оформить, а также обеспечить правильную переходку (в особенности касается child-ов).
Вообщем как я и говорил, малёк повис на этих БД. Завтра, в первую очередь, надо сосредоточиться на том, что я могу сделать уже сейчас.
Хотя бы все Вьюхи подготовить и оформить интерфейс.
/<

>/ 19/09/18
Чёт мне варик с реализацией списка комманд для кнопок совсем не нравится. Мне вот стопроцентов подсказывает чутье, что не так это делается. Ибо с каждым последующим углублением по дереву
в мэйне нужно заводить список всё сложнее и сложнее. Всё-таки надо скорее всего отписать Виталику с уника. Я думаю, что он подскажет и наведет на правильную мысль, в конце концов, что я теряю.
Конечно в моём случае нужен Prism или MVVMLight, потому что я чую, что в обратном случае будет грязь. 
Проблема в том, что в примере челика wpfapplication он пользуется MVVMLight, но в то же время у него есть немного code-behind, но вроде как он легко правится. Зато он, как я вычитал в 
статье челика-протогониста Josh Smith, делает классы сообщений отдельно.
Челик с хабра в третьем примере пользуется Prism, но у него всё в одной куче. Можно попробовать воспользоваться EventAggregator-ом челика-протогониста (ссылка в телеге) и всё-таки попытать счастье
в использовании Prism. Тут основная загвоздка в том, что я не перенесу проект скорее всего вот так вот сразу на Prism. Тоесть мне теперь придется править проект с хабра.
Надо понять делегаты, будет супер. Статейку нашёл, надо пробовать читать, может что вычитаю (prismlibrary.github...). Потом на основе этого разобрать пример с хабра и запилить навигейшен.
Короче вычитал, что когда xaml байндится к Коллекции, то автоматом создается CollectionViewSource class, который поставляет IsSelected, что вообще шикарно для меня. Но это надо проверить.
Впринципе пока что ничего особо прямо полезного. Конечно информации о: построении общего контекста программа, что и когда использовать, - дофига. Но всё равно пока что живого примера не видно.
Разобрался с проблемой двойного нажатия при помощи Attached Property (ссылка в Телеге), что уже какой-никакой, а результат.
Вообщем почитать-то, я почитал, и вроде даже стало немного яснее. Но проблемы моей это не решило. Надо проникнуться самими делегатами и продебажить 2 примера, один с хабра, второй - wpfentity...
Потому что там уже введены MvvMLight и Prism, которые как бы подразумевают собой навигацию. Осталось понять, как именно её оформить в рамках моего проекта.
Короче с навигацией всё сложно. Завтра попробую то, что есть в голове и самое простое, без использования дополнительных наворотов. Если не выйдет, придется понять эти навороты.
Мне кажется, что в любом случае придется понять эти навороты. Мб легче пока что с валидацией и БД разобраться? Ибо навигация - это дело такое, наживное, я бы сказал.
Конечно без неё прога нифига не рабочая, а показывать её в табах как-то совсем не камильфо, но всё же я всё-таки продвинусь намного дальше таким образом, как мне кажется.
/<

>/ 20/09/18
Такс, что мы пытаемся сделать сегодня. Надо делать всё то, что я впринципе знаю, как сделать (ключевой момент). А на конец оставлять улучшение существующего функционала либо те детали, которые я вообще не знаю, как сделать. Таким образом, я впринципе понимаю, как оформить валидацию, как сделать вьюшки и формы (единственная проблема остается конечно со второй формой - именно детишек, но каркасс-то хотя бы можно же сделать). Я впринципе понимаю, как оформить интерфейс в целом (пусть хотя бы выглядит всё красиво, хоть и будет пока что не совсем рабочим). Далее, я впринципе понимаю, как сделать кнопки, общие для всех Вьюх, и может даже у меня получится запилить выборку с IsSelected для кнопок в купе с активацией и деактивацией кнопок. Со всем этим так же тесно связаны коннекты к БД и выборка данных оттуда. И на закуску конечно же навигация. Пока что хоть какая, в идеале, потом усовершенствуется.
Ещё конечно меня гложит вопрос с организацией класса AllGroupViewModel как класса-коллекции. Возможно это поможет избавиться от проблемы связи дети-родители. Потому что в этом пока что заключается сложность. Ведь при создании списка моделей, их же надо как-то раскидывать. Возникла идея сразу добавить что-то вроде свойства Parent. Но тогда при изменении этого самого Пэрэнта будет возникать конфликт.
Тоесть если и брать Пэрэнта, то не копию объекта класса, а просто имя. Короче есть казус.
Дизигнер из меня, как выяснилось, такой себе. Пока что как есть. Всё равно меняться все будет, зачем сейчас фулл трогать дизайн. Немного поковырял, больше вник, и отлично.
Пусть список просто повисит здесь (кратенький, тезисный):
1)Вьюшки + формы (каркасс) + валидация в формах на заполнение.
2)Интерфейс в целом.
3)Общие кнопки CRUD в мэйне для всех + логика с IsSelected.
4)Коннекты к БД и выборка данных (пока что к главной БД).
5)Навигация.
/<

>/ 21/09/18
Задачи впринципе всё те же. Вчера остановился на создании Context и подгрузки БД. Начнем с этого и в идеале добьём. Далее останутся кнопки, навигэйшн и всякая доп логика, которая пока что не так принципиальна. В купе с навигэйшином ещё хочется, я так прикинул, как-то автоматизировать создание дерева элементов-кнопок.
С контекстом вроде все вышло и даже подгрузилось. Seems good. Есть правда вопросы как именно его использовать, когда закрывать, когда создавать заново. Вроде как сейвишь и используешь в using (context). Просто проще менять контекст сам по себе, а не передавать его через список, как делаю я. Потому что потом, после работы со списком, это каким-то образом надо перекидывать обратно в DataContext. А для этого нужны будут левые функции, типа трекинга изменений как в Git и т.д. Зачем это нужно, если можно работать напрямую с DataContext.
Оказывается using() это просто короткая запись try/catch с вызовом Dispose() в finally.
Пришла в голову идея, что мэйби навигация через TreeView была бы привлекательнее и удобнее. Смотря как они привыкли работать конечно. Можно впринципе запилить и то, и другое. Типа, кому как удобно. Пока что пилим один более ли менее привлекательный варик для презента. Потом будем разбираться с доп фичами.
Можно посматривать на пример AndyOneil(собственно автор wpf_EntityFramework проекта). Там все так же красиво сделано в стиле наследований, только ещё добавлена навигация через MVVM.Light.
Во ВТОРОЙ части (а их всего две) есть валидация + метадата. Вообще в двух примерах есть хорошие примеры работы с БД. Конечно брать фулл его пример и пытаться переделывать, после того, как я столько парюсь с этим, - не лучшее решение явно. Но какие-то функции глянуть будет шикарно. Мэйби даже проследить логику навигаций там и забахать себе такую же логику. 
Нашел много сходств между моим проектом и проектом wpfEntityFr*. Ключевым отличием является то, что там просто не от одного базового класса все наследуются, а от двух.
Плюс к тому связь между таблицами все-таки реализована путем создания объектов-методов. К примеру, если у меня есть связь один-ко-многим между группой и детьми, то в классе Group у меня 
будет ICollection<Child> Childs к примеру, а в классе Child будет Group group. Как-то так вообщем. В моем случае правда такая же штука должна быть и во ViewModel. Но как-то непонятно пока что
как это реально сделать лучше всего. С навигацией, как выяснилось при детальном рассмотрении, челик всё-таки поленился. Он завел фрейм, регистрирует сообщения по Навигации(причем в code-behind к MainView), а затем просто свойству Content мэйна присваивает свойство View, которое хранится в сообщении. Мне это вообще никак не подходит. Тем более учитывая, что мне как минимум надо имя ViewModel ловить.
Пхах. Навигация всё-таки вышла, но даже мне такое решение кажется настолько глупым, что трындец. Слишком много костылей. DBContext однако вороде отлично работает. Я правда ничего особенного не
делал, но вроде в моем случае мэйби и не нужны сторонние библиотеки. Вообщем не ясно пока что. Пока не начну использовать функция добавления, редактирования, сохранения и удаления, не пойму всё равно скорее всего. Опять же, в той же навигации я передаю вообще int. Мне по-любому надо объект передавать, причем по ссылке. Либо райзить каждый раз проверку. Потому что если человек изменит информацию о коде группы, то поменяется полностью весь список чайлдов. По идеи тогда, мне надо удалять модель из воркспейса и создавать новую. Либо райзить ивент при любом изменении проперти объекта. Сложно сказать что легче, а уж тем более правильнее.
/<

>/ 24/09/18
Вычитал про Dapper для работы с БД. Потестил, летает. Без всяких контекстов и доп ключей.
Короче я понял, что мне ведь как-то апдейтить всё нужно динамически по идеи. Или нет. По сути у меня слишком легкая схема. И всё. что касается апдейтов, мне кажется, я могу выполнять и на лету. Либо используя функции. Короче я как всегда лезу в дебри, с этим мне возможно придется познакомится позже, а пока что надо вернуться к самому простому.
Короче чую пока что проще сделать криво. Вроде как можно сделать шикарную навигацию через MVVMLight и делегаты с историей и т.д. Но какие бы я примеры не находил, везде натыкаюсь на какие-то нестыковки. Либо там переключение страниц (так спрашивается зачем сторонние приложения, если навигация между страницами и так присутствует по дефолту, если я всё так понимаю конечно). На офф сайте есть видео, возможно проще глянуть их и тогда получится вникнуть в суть дела. Пока что сообщение между окнами с помощью Messaging - для меня темный лес.
Нужно реализовать ещё целую пачку апдейтов. По идеи это что-то вроде триггеров. То есть если апдейтится запись в таблице группы, то автоматически должны апдейтиться записи в таблице Childs.
Вообщем всё равно чувствуется просто элементарно пробел в знаниях. Суть в том, что я просто не понимаю, что и как мне нужно запрогать. Нужны туториалы с последовательным построением приложухи с нуля. Однако проблема в том, что это много времени во-первых, во-вторых - примеры в основном легкие.
Короче по поводу навигации: остановился на задании свойства Visibility, осталось прибайндить его к Воркспейсам и рейзить ивент. Завтра поопробуем.
/<

>/ 25/09/18
Вообщем связь все-таки организуется добавлением соответствующих полей (имеется в виду ObservableCollection). Причём как во ViewModel, так и в Model. Во вью Модельке мы по сути работаем со списками (коллекциями) всегда. Нужно попробовать организовать такую вещь. Всё-таки конечно, если всё будет завязано, будет намного удобнее организовывать связь Parent->Child. Минус такого подхода в том, что мне в каждом классе придется организовывать схожий функционал. По сути это повторение кода. Да и главная проблема в том, что раз у меня кнопки все в мэйне, то мне нужно тречить, что именно в данный момент у меня выбрано. По идеи конечно заводишь свойство IsSelected и до любого нужного объекта можно достучаться из мэйна (наверное).
Вообщем мне не нравится моя модель. Поэтому я попытаюсь с этого момента пойти на глобальную переработку. Копию работающую засейвлю. Можно конечно было бы бренч сделать в GitHub, заодно прочувствовать, что это такое. Но потом путаться, забывать вечно Brench менять, к черту короче.
/<
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//Связка с MS SQL Server (впринципе неактульно уже, потому что мы перешли на SQLite)
>/
Строка подключения:
Server=localhost\SQLEXPRESS;Database=master;Trusted_Connection=True;

Админы:	
DESKTOP-V5H0EAM\vladwoode
/<

//Мысли на ходу по поводу проги
>/
Так, ладно. Это становится дико сложно. Нужно раскидать задачу на маленькие подзадачки.
1)Сделать кнопку, которая при нажатии будет плодить другие кнопки. Всё это дело выровнять.
2)К этой радости Приделать View Model.
3)Будет легкая БД SQL Lite скоре всего. В ней будут храниться 2 таблицы буквально.
Группы и их дети (по сути сам каталог и товары внутри каждой группы).
4)Функции в главном окне: Add, Edit, Delete, Update.
5)Кнопку добавления большую можно попытаться конечно сделать, но возникла проблема всунуть его DataTemplate.
Не понимаю пока что, как вставить. Пока что будет кнопка добавление маленькая в ToolKit-е над каталогом.
Правда в таком случае опять же нужен тогда ListView, а не Button. При Edit-е будет вылетать UserControl в идеале.
/<